<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gunjs Template</title>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js" integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+" crossorigin="anonymous"></script>
    <script src="./gun/gun.js"></script>
    <script src="./gun/sea.js"></script>
    <script src="./gun/lib/radix.js"></script>
    <script src="./gun/lib/radisk.js"></script>
    <script src="./gun/lib/store.js"></script>
    <script src="./gun/lib/rindexed.js"></script>
    <script src="./libs.js"></script>
    <script src="./debugger.js"></script>
    <script src="./iochannel.js"></script>
    <script src="./rtcpeer.js"></script>
</head>
<body>
    
</body>
<script>
    const _debugger = Debugger("html", true)
    async function init(room, peer, pair) {
        window.pair = pair ??= await SEA.pair()
        localStorage.clear()
    
        gun = Gun()
        user = gun.user()
        user.auth(pair)
        mesh = gun.back("opt.mesh")

        channel = new SignalingChannel(gun.back("opt.uuid")(), "https://test.master.glubl.io/", "swololo")
        let p = new Promise((res) => {
            channel.socket.on("connect", function fn() {
                channel.socket.off("connect", fn)
                res()
            })
        })
        channel.connect()
        await p
        channel.socket.on("initRTC", initRTC)
        channel.socket.on("gun-exec", initTest)
    }

    netPeers = {}
    rtcPeers = {}
    async function initRTC(peers) {
        _debugger.log(peers)
        let oldPeers = new Set(Object.keys(rtcPeers))
        for (const peerId of peers) {
            oldPeers.delete(peerId) 
            _debugger.log(peerId)
            if (peerId in rtcPeers && rtcPeers[peerId].rtc.isConnected) continue
            let tmp
            let p = rtcPeers[peerId] ??= {}
            let gunPeer = p.rtc ??= new RTCPeer(peerId, channel.peerId)
            
            let peerPub = undefined
            let sendFn = p.sendFn = async (msg) => {
                var dat = msg
                if (!!peerPub) {
                    let enc = await SEA.encrypt(msg, peerPub.shared)
                    dat = await SEA.sign(enc, pair)
                }
                channel.sendTo(peerId, dat)
            }
            let recvFn = p.recvFn = async (msg) => {
                let { target, from, payload } = msg||{}
                if (target !== channel.peerId || from !== peerId) return
                if (!peerPub) {
                    if (!!payload.pub && !!payload.epub) {
                        sendFn({ pub: pair.pub, epub: pair.epub })
                        peerPub = netPeers[peerId] = { 
                            pub: payload.pub, 
                            epub: payload.epub,
                            shared: await SEA.secret(payload.epub, pair)
                        }
                        gunPeer.connect()
                    } 
                    return
                }
                if (typeof payload !== "string") return
                let enc = await SEA.verify(payload, peerPub.pub)
                let dat = await SEA.decrypt(enc, peerPub.shared)
                if (!dat) {
                    _debugger.warn("No data!")
                    return
                }
                gunPeer.emit("recv-signal", dat)
            }
            
            channel.socket.on("message", recvFn)
            gunPeer.on("send-signal", sendFn)
            sendFn({ pub: pair.pub, epub: pair.epub })
            
            function close() {
                _debugger.log("{{data channel}} close", this.label)
                gunPeer.wire = null
                mesh.bye(gunPeer)
            }
            function error(ev) {
                _debugger.log("{{data channel}} error", this.label, ev)
                gunPeer.wire = null
                mesh.bye(gunPeer)
            }
            function open() {
                _debugger.log("{{data channel}} open", this.label)
                gunPeer.wire = this
                gunPeer.id = peerId
                channel.socket.emit("gun-ready", {})
                mesh.hi(gunPeer)
            }
            function message(msg) {
                if (!msg.data) return
                //_debugger.log("::msg::", msg.data)
                mesh.hear(msg.data, gunPeer)
            }
            rtcPeers[peerId].rtc.addDataChannel('gun', message, open, close, error)
        }
        for (peerId of oldPeers) {
            rtcPeers[peerId].rtc.off("send-signal", rtcPeers[peerId].sendFn)
            channel.socket.off("message", rtcPeers[peerId].recvFn)
            rtcPeers[peerId].rtc.disconnect()
            delete rtcPeers[peerId]
        }
    }

    async function initTest() {
        gun.get("profiles").get(channel.peerId).put({
            pub: pair.pub,
            epub: pair.epub
        })
        gun.get("test").get(channel.peerId).map().on(async (v, k, meta, e) => {
            let t2 = +new Date
            console.log("Recv")
            const { d, ts, pub, epub, peerId } = JSON.parse(v||'') || {}
            if (!d || !ts || !pub || !epub || !peerId) {
                console.error("Invalid data", v)
                return
            }
            if (pub === pair.pub) return
            
            let { shared } = netPeers[peerId] ??= {
                pub: pub,
                epub: epub,
                shared: await SEA.secret(epub, pair)
            }
            let enc = await SEA.verify(d, pub)
            let dat = await SEA.decrypt(enc, shared)
            if (!dat) {
                console.error("Can't decrypt data", dat, env, d, netPeers[peerId])
                return
            }
            
            console.log('Send ack')
            // TODO
            gun.on('out', {
                '@': ''+meta["#"],                                       
                'ok': await SEA.sign(
                    await SEA.encrypt({
                        t1: ts,
                        t2: t2,
                        t3: +new Date
                    }, shared)
                )
            })
        })
    }
    init()
</script>
</html>